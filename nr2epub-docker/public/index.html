<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>nr2epub</title>
    <style>
      body {
        font-family: "Noto Sans JP", "Hiragino Kaku Gothic Pro", "Meiryo", sans-serif;
        margin: 32px;
      }
      .wrap {
        max-width: 720px;
        margin: 0 auto;
      }
      label {
        display: block;
        margin: 12px 0 6px;
      }
      input, button {
        font-size: 16px;
        padding: 8px 10px;
      }
      input {
        width: 100%;
        box-sizing: border-box;
      }
      button {
        margin-top: 12px;
        margin-right: 8px;
      }
      .button-group {
        display: flex;
        gap: 8px;
        margin-top: 12px;
      }
      .button-group button {
        flex: 1;
        margin: 0;
      }
      pre {
        background: #f5f5f5;
        padding: 12px;
        white-space: pre-wrap;
        max-height: 300px;
        overflow-y: auto;
      }
      .settings-section {
        margin-top: 48px;
        padding-top: 24px;
        border-top: 2px solid #ddd;
      }
      .settings-section h2 {
        font-size: 1.2em;
        margin-bottom: 12px;
      }
      .settings-buttons {
        display: flex;
        gap: 8px;
        margin-top: 12px;
      }
      .settings-buttons button {
        flex: 1;
        margin: 0;
      }
      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <h1>nr2epub - EPUBç”Ÿæˆ</h1>
      <p>ãªã‚ã†ä½œå“URLã‚’å…¥åŠ›ã—ã¦ã€EPUBç”Ÿæˆã¾ãŸã¯ãƒ¡ãƒ¼ãƒ«é€ä¿¡ã‚’è¡Œã„ã¾ã™ã€‚</p>
      
      <label for="work-url">ä½œå“URL</label>
      <input id="work-url" placeholder="https://ncode.syosetu.com/xxxxxx/" />
      <button id="extract-button">è©±ãƒšãƒ¼ã‚¸ã‚’æŠ½å‡º</button>

      <label for="episodes">è©±ç•ªå·ï¼ˆã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã¾ãŸã¯ç¯„å›²: 1,2,3 ã¾ãŸã¯ 1-10ï¼‰</label>
      <input id="episodes" placeholder="1-50" />
      
      <label for="epub-author">è‘—è€…åï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åç”¨ï¼‰</label>
      <input id="epub-author" placeholder="è‘—è€…å" />
      
      <label for="epub-title">ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åç”¨ï¼‰</label>
      <input id="epub-title" placeholder="ã‚¿ã‚¤ãƒˆãƒ«" />
      
      <label for="mail-recipient">é€ä¿¡å…ˆãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ï¼ˆãƒ¡ãƒ¼ãƒ«é€ä¿¡æ™‚ã®ã¿ï¼‰</label>
      <input id="mail-recipient" placeholder="you@example.com" />
      
      <details style="margin-top: 16px;">
        <summary style="cursor: pointer; font-weight: bold;">ğŸ“§ SMTPè¨­å®šï¼ˆãƒ¡ãƒ¼ãƒ«é€ä¿¡ç”¨ï¼‰</summary>
        <div style="margin-top: 12px; padding: 12px; background: #f9f9f9; border-radius: 4px;">
          <label for="smtp-host" style="margin-top: 8px;">SMTPãƒ›ã‚¹ãƒˆ</label>
          <input id="smtp-host" placeholder="smtp.gmail.com" />
          
          <label for="smtp-port" style="margin-top: 8px;">SMTPãƒãƒ¼ãƒˆ</label>
          <input id="smtp-port" type="number" placeholder="587" />
          
          <label for="smtp-user" style="margin-top: 8px;">SMTPãƒ¦ãƒ¼ã‚¶ãƒ¼åï¼ˆãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ï¼‰</label>
          <input id="smtp-user" placeholder="your-email@gmail.com" />
          
          <label for="smtp-pass" style="margin-top: 8px;">SMTPãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼ˆã‚¢ãƒ—ãƒªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼‰</label>
          <input id="smtp-pass" type="password" placeholder="ã‚¢ãƒ—ãƒªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰" />
          
          <div style="margin-top: 8px;">
            <label>
              <input type="checkbox" id="smtp-secure" />
              SSL/TLSæ¥ç¶šã‚’ä½¿ç”¨ (é€šå¸¸ã¯ãƒãƒ¼ãƒˆ465ã®å ´åˆã«ãƒã‚§ãƒƒã‚¯)
            </label>
          </div>
          
          <p style="font-size: 0.85em; color: #666; margin-top: 8px;">
            ğŸ’¡ Gmailã®å ´åˆ: <a href="https://myaccount.google.com/apppasswords" target="_blank">ã‚¢ãƒ—ãƒªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰</a>ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„
          </p>
        </div>
      </details>
      
      <div class="button-group">
        <button id="download-button">EPUBã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
        <button id="mail-button">EPUBã‚’ãƒ¡ãƒ¼ãƒ«ã§é€ä¿¡</button>
      </div>
      
      <pre id="output"></pre>

      <div class="settings-section">
        <h2>âš™ï¸ è¨­å®šç®¡ç†</h2>
        <p style="font-size: 0.9em; color: #666;">è¨­å®šã¯ãƒ–ãƒ©ã‚¦ã‚¶ã«è‡ªå‹•ä¿å­˜ã•ã‚Œã¾ã™ã€‚</p>
        <div class="settings-buttons">
          <button id="export-button">è¨­å®šã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
          <button id="import-button">è¨­å®šã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
          <button id="clear-button">è¨­å®šã‚’ã‚¯ãƒªã‚¢</button>
        </div>
        <input type="file" id="import-file" class="hidden" accept=".json" />
      </div>
    </div>
    <script>
      const workUrlInput = document.getElementById("work-url");
      const episodesInput = document.getElementById("episodes");
      const epubAuthorInput = document.getElementById("epub-author");
      const epubTitleInput = document.getElementById("epub-title");
      const mailRecipientInput = document.getElementById("mail-recipient");
      const smtpHostInput = document.getElementById("smtp-host");
      const smtpPortInput = document.getElementById("smtp-port");
      const smtpUserInput = document.getElementById("smtp-user");
      const smtpPassInput = document.getElementById("smtp-pass");
      const smtpSecureInput = document.getElementById("smtp-secure");
      const extractButton = document.getElementById("extract-button");
      const downloadButton = document.getElementById("download-button");
      const mailButton = document.getElementById("mail-button");
      const output = document.getElementById("output");
      const exportButton = document.getElementById("export-button");
      const importButton = document.getElementById("import-button");
      const clearButton = document.getElementById("clear-button");
      const importFile = document.getElementById("import-file");
      
      const apiBase = window.location.origin === "null" ? "http://localhost:3000" : "";

      // è¨­å®šã®ä¿å­˜ã¨èª­ã¿è¾¼ã¿
      const SETTINGS_KEY = "nr2epub_settings";
      
      function saveSettings() {
        const settings = {
          mailRecipient: mailRecipientInput.value,
          epubAuthor: epubAuthorInput.value,
          epubTitle: epubTitleInput.value,
          lastWorkUrl: workUrlInput.value,
          lastEpisodes: episodesInput.value,
          smtp: {
            host: smtpHostInput.value,
            port: smtpPortInput.value,
            user: smtpUserInput.value,
            pass: smtpPassInput.value,
            secure: smtpSecureInput.checked
          }
        };
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
      }
      
      function loadSettings() {
        try {
          const saved = localStorage.getItem(SETTINGS_KEY);
          if (saved) {
            const settings = JSON.parse(saved);
            if (settings.mailRecipient) mailRecipientInput.value = settings.mailRecipient;
            if (settings.epubAuthor) epubAuthorInput.value = settings.epubAuthor;
            if (settings.epubTitle) epubTitleInput.value = settings.epubTitle;
            if (settings.lastWorkUrl) workUrlInput.value = settings.lastWorkUrl;
            if (settings.lastEpisodes) episodesInput.value = settings.lastEpisodes;
            if (settings.smtp) {
              if (settings.smtp.host) smtpHostInput.value = settings.smtp.host;
              if (settings.smtp.port) smtpPortInput.value = settings.smtp.port;
              if (settings.smtp.user) smtpUserInput.value = settings.smtp.user;
              if (settings.smtp.pass) smtpPassInput.value = settings.smtp.pass;
              if (settings.smtp.secure !== undefined) smtpSecureInput.checked = settings.smtp.secure;
            }
          }
        } catch (err) {
          console.error("Failed to load settings:", err);
        }
      }
      
      function exportSettings() {
        const settings = {
          mailRecipient: mailRecipientInput.value,
          epubAuthor: epubAuthorInput.value,
          epubTitle: epubTitleInput.value,
          lastWorkUrl: workUrlInput.value,
          lastEpisodes: episodesInput.value,
          smtp: {
            host: smtpHostInput.value,
            port: smtpPortInput.value,
            user: smtpUserInput.value,
            pass: smtpPassInput.value,
            secure: smtpSecureInput.checked
          },
          exportedAt: new Date().toISOString()
        };
        const blob = new Blob([JSON.stringify(settings, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = `nr2epub_settings_${new Date().toISOString().split('T')[0]}.json`;
        link.click();
        URL.revokeObjectURL(url);
        output.textContent = "âœ… è¨­å®šã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ";
      }
      
      function importSettings(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const settings = JSON.parse(e.target.result);
            if (settings.mailRecipient) mailRecipientInput.value = settings.mailRecipient;
            if (settings.epubAuthor) epubAuthorInput.value = settings.epubAuthor;
            if (settings.epubTitle) epubTitleInput.value = settings.epubTitle;
            if (settings.lastWorkUrl) workUrlInput.value = settings.lastWorkUrl;
            if (settings.lastEpisodes) episodesInput.value = settings.lastEpisodes;
            if (settings.smtp) {
              if (settings.smtp.host) smtpHostInput.value = settings.smtp.host;
              if (settings.smtp.port) smtpPortInput.value = settings.smtp.port;
              if (settings.smtp.user) smtpUserInput.value = settings.smtp.user;
              if (settings.smtp.pass) smtpPassInput.value = settings.smtp.pass;
              if (settings.smtp.secure !== undefined) smtpSecureInput.checked = settings.smtp.secure;
            }
            saveSettings();
            output.textContent = `âœ… è¨­å®šã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ${settings.exportedAt ? ' (ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ—¥: ' + new Date(settings.exportedAt).toLocaleString() + ')' : ''}`;
          } catch (err) {
            output.textContent = `ã‚¨ãƒ©ãƒ¼: è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ - ${err.message}`;
          }
        };
        reader.readAsText(file);
      }
      
      function clearSettings() {
        if (confirm("ã™ã¹ã¦ã®è¨­å®šã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ")) {
          localStorage.removeItem(SETTINGS_KEY);
          mailRecipientInput.value = "";
          epubAuthorInput.value = "";
          epubTitleInput.value = "";
          smtpHostInput.value = "";
          smtpPortInput.value = "";
          smtpUserInput.value = "";
          smtpPassInput.value = "";
          smtpSecureInput.checked = false;
          output.textContent = "âœ… è¨­å®šã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ";
        }
      }
      
      // è¨­å®šãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆ
      exportButton.addEventListener("click", exportSettings);
      importButton.addEventListener("click", () => importFile.click());
      importFile.addEventListener("change", (e) => {
        if (e.target.files.length > 0) {
          importSettings(e.target.files[0]);
          e.target.value = "";
        }
      });
      clearButton.addEventListener("click", clearSettings);
      
      // å…¥åŠ›å¤‰æ›´æ™‚ã«è‡ªå‹•ä¿å­˜
      mailRecipientInput.addEventListener("input", saveSettings);
      workUrlInput.addEventListener("input", saveSettings);
      episodesInput.addEventListener("input", saveSettings);
      smtpHostInput.addEventListener("input", saveSettings);
      smtpPortInput.addEventListener("input", saveSettings);
      smtpUserInput.addEventListener("input", saveSettings);
      smtpPassInput.addEventListener("input", saveSettings);
      smtpSecureInput.addEventListener("change", saveSettings);
      
      // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«è¨­å®šã‚’å¾©å…ƒ
      loadSettings();

      const postJson = async (path, body) => {
        const res = await fetch(`${apiBase}${path}`, {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify(body)
        });
        return res;
      };

      const readResponseJson = async (res) => {
        const text = await res.text();
        try {
          return JSON.parse(text);
        } catch {
          return { raw: text };
        }
      };

      extractButton.addEventListener("click", async () => {
        const url = workUrlInput.value.trim();
        if (!url) {
          output.textContent = "URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„";
          return;
        }
        output.textContent = "loading...";
        try {
          const res = await postJson("/api/parse-work", { url });
          const json = await readResponseJson(res);
          
          if (json.data) {
            // è‘—è€…åã¨ã‚¿ã‚¤ãƒˆãƒ«ã‚’æ¯å›æ›´æ–°ï¼ˆå‰ã®å€¤ã¯ä¸Šæ›¸ãï¼‰
            epubAuthorInput.value = json.data.author || "";
            epubTitleInput.value = json.data.title || "";
            
            const episodeCount = json.data.maxEpisode > 0 ? json.data.maxEpisode : (json.data.episodes?.length || 0);
            if (episodeCount > 0) {
              episodesInput.value = `1-${episodeCount}`;
              output.textContent = `æŠ½å‡ºæˆåŠŸï¼è©±æ•°: ${episodeCount}`;
            } else {
              output.textContent = `æŠ½å‡ºå®Œäº†ï¼ˆè©±æ•°ä¸æ˜ï¼‰`;
            }
            saveSettings();
          }
        } catch (err) {
          output.textContent = `ã‚¨ãƒ©ãƒ¼: ${err.message || err}`;
        }
      });
      
      const parseEpisodeNumbers = (input) => {
        const numbers = [];
        const parts = input.split(",").map(p => p.trim());
        for (const part of parts) {
          if (part.includes("-")) {
            const [start, end] = part.split("-").map(n => parseInt(n, 10));
            if (!isNaN(start) && !isNaN(end)) {
              for (let i = start; i <= end; i++) {
                numbers.push(i);
              }
            }
          } else {
            const num = parseInt(part, 10);
            if (!isNaN(num)) numbers.push(num);
          }
        }
        return numbers;
      };

      const buildEpisodeUrls = (workUrl, requestedEpisodes, allEpisodes) => {
        const baseUrl = workUrl.endsWith('/') ? workUrl.slice(0, -1) : workUrl;
        const isNarouNumbered = /^https?:\/\/(ncode|novel18)\.syosetu\.com\/[^/]+\/?$/.test(workUrl);

        return requestedEpisodes
          .map((episodeNum) => {
            const byIndex = allEpisodes[episodeNum - 1]?.url;
            if (byIndex) return byIndex;

            const byEpisodeField = allEpisodes.find(ep => ep?.episode === episodeNum)?.url;
            if (byEpisodeField) return byEpisodeField;

            if (isNarouNumbered) {
              return `${baseUrl}/${episodeNum}/`;
            }

            return null;
          })
          .filter(Boolean);
      };
      
      downloadButton.addEventListener("click", async () => {
        const url = workUrlInput.value.trim();
        const episodeStr = episodesInput.value.trim();
        
        if (!url) {
          output.textContent = "ä½œå“URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„";
          return;
        }
        if (!episodeStr) {
          output.textContent = "è©±ç•ªå·ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆã¾ãŸã¯æŠ½å‡ºãƒœã‚¿ãƒ³ã§è‡ªå‹•å…¥åŠ›ï¼‰";
          return;
        }
        
        output.textContent = "ä½œå“æƒ…å ±ã‚’å–å¾—ä¸­...";
        try {
          const res = await postJson("/api/parse-work", { url });
          const workData = await readResponseJson(res);
          
          if (!workData.data) {
            output.textContent = "ä½œå“æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ";
            return;
          }
          
          const episodes = parseEpisodeNumbers(episodeStr);
          const allEpisodes = workData.data.episodes || [];
          const episodeUrls = buildEpisodeUrls(url, episodes, allEpisodes);
          
          if (episodeUrls.length === 0) {
            output.textContent = "è©±ç•ªå·ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“";
            return;
          }

          if (episodeUrls.length !== episodes.length) {
            output.textContent = `âŒ æŒ‡å®š ${episodes.length} è©±ã®ã†ã¡URLã‚’è§£æ±ºã§ããŸã®ã¯ ${episodeUrls.length} è©±ã§ã™ã€‚è©±ç•ªå·æŒ‡å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚`;
            return;
          }
          
          // è‘—è€…åã¨ã‚¿ã‚¤ãƒˆãƒ«ã‚’å–å¾—
          const author = epubAuthorInput.value.trim() || workData.data.author || "Unknown";
          const title = epubTitleInput.value.trim() || workData.data.title || "Untitled";
          
          output.textContent = `EPUBç”Ÿæˆã‚¸ãƒ§ãƒ–ã‚’é–‹å§‹ä¸­... (${episodeUrls.length}è©±äºˆå®š)`;
          
          // /api/generate-epub ã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰(sendEmail=false)ã§å‘¼ã³å‡ºã—
          const downloadRes = await postJson("/api/generate-epub", {
            workUrl: url,
            episodeUrls,
            author,
            title,
            sendEmail: false
          });
          const downloadData = await readResponseJson(downloadRes);
          
          if (downloadRes.status === 202 && downloadData.jobId) {
            // ã‚¸ãƒ§ãƒ–ãŒé–‹å§‹ã•ã‚ŒãŸ - ãƒãƒ¼ãƒªãƒ³ã‚°ã§é€²æ—ã‚’ç¢ºèª
            const jobId = downloadData.jobId;
            let completed = false;
            
            while (!completed) {
              await new Promise(resolve => setTimeout(resolve, 500)); // 0.5ç§’ã”ã¨ã«ãƒãƒ¼ãƒªãƒ³ã‚°
              
              const progressRes = await fetch(`${apiBase}/api/job-progress/${jobId}`, { cache: "no-store" });
              if (!progressRes.ok) {
                output.textContent = "é€²æ—ç¢ºèªã«å¤±æ•—ã—ã¾ã—ãŸ";
                break;
              }
              
              const progress = await progressRes.json();
              if (progress.status === "processing") {
                output.textContent = `${progress.message || "EPUBç”Ÿæˆä¸­..."} (${progress.progress}/${progress.total}è©±)`;
              } else {
                output.textContent = `${progress.message || `EPUBç”Ÿæˆä¸­... ${progress.progress}/${progress.total}è©±`}`;
              }
              
              if (progress.status === "completed") {
                output.textContent = `EPUBç”Ÿæˆå®Œäº†ã€‚ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­...`;
                saveSettings();
                
                // EPUB ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                try {
                  const epubRes = await fetch(`${apiBase}/api/download/${jobId}`);
                  if (!epubRes.ok) {
                    output.textContent = `âŒ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å¤±æ•—: ${epubRes.status}`;
                    completed = true;
                    return;
                  }
                  
                  const blob = await epubRes.blob();
                  const downloadUrl = URL.createObjectURL(blob);
                  const link = document.createElement('a');
                  link.href = downloadUrl;

                  const contentDisposition = epubRes.headers.get('content-disposition') || '';
                  let headerFilename = '';
                  const filenameMatch = contentDisposition.match(/filename="?([^";]+)"?/i);
                  if (filenameMatch && filenameMatch[1]) {
                    try {
                      headerFilename = decodeURI(filenameMatch[1]);
                    } catch {
                      headerFilename = filenameMatch[1];
                    }
                  }

                  const fallbackFilename = author && author.trim()
                    ? `[${author}]${title}.epub`
                    : `${title}.epub`;
                  link.download = headerFilename || progress.filename || fallbackFilename;
                  link.click();
                  URL.revokeObjectURL(downloadUrl);
                  
                  output.textContent = `âœ… ${progress.message || `EPUB ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº† (${progress.total}è©±)`}`;
                } catch (downloadErr) {
                  output.textContent = `âŒ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­ã«ã‚¨ãƒ©ãƒ¼: ${downloadErr.message}`;
                }
                
                completed = true;
              } else if (progress.status === "error") {
                output.textContent = `âŒ ã‚¨ãƒ©ãƒ¼: ${progress.error || "ä¸æ˜ãªã‚¨ãƒ©ãƒ¼"}`;
                completed = true;
              }
            }
          } else {
            const error = downloadData.error || "ä¸æ˜ãªã‚¨ãƒ©ãƒ¼";
            output.textContent = `ç”Ÿæˆã‚¨ãƒ©ãƒ¼: ${error}`;
          }
        } catch (err) {
          output.textContent = `ã‚¨ãƒ©ãƒ¼: ${err.message || err}`;
        }
      });
      
      mailButton.addEventListener("click", async () => {
        const url = workUrlInput.value.trim();
        const episodeStr = episodesInput.value.trim();
        const mailRecipient = mailRecipientInput.value.trim();
        
        if (!url) {
          output.textContent = "ä½œå“URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„";
          return;
        }
        if (!episodeStr) {
          output.textContent = "è©±ç•ªå·ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆã¾ãŸã¯æŠ½å‡ºãƒœã‚¿ãƒ³ã§è‡ªå‹•å…¥åŠ›ï¼‰";
          return;
        }
        if (!mailRecipient) {
          output.textContent = "ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„";
          return;
        }
        
        // SMTPè¨­å®šã®å–å¾—
        const smtp = smtpHostInput.value && smtpUserInput.value && smtpPassInput.value ? {
          host: smtpHostInput.value || "smtp.gmail.com",
          port: parseInt(smtpPortInput.value) || 587,
          user: smtpUserInput.value,
          pass: smtpPassInput.value,
          secure: smtpSecureInput.checked
        } : undefined;
        
        if (!smtp) {
          output.textContent = "SMTPè¨­å®šã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚ã€ŒğŸ“§ SMTPè¨­å®šã€ã‚’é–‹ã„ã¦æƒ…å ±ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚";
          return;
        }
        
        output.textContent = "ä½œå“æƒ…å ±ã‚’å–å¾—ä¸­...";
        try {
          const res = await postJson("/api/parse-work", { url });
          const workData = await readResponseJson(res);
          
          if (!workData.data) {
            output.textContent = "ä½œå“æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ";
            return;
          }
          
          const episodes = parseEpisodeNumbers(episodeStr);
          const allEpisodesMail = workData.data.episodes || [];
          const episodeUrls = buildEpisodeUrls(url, episodes, allEpisodesMail);
          
          if (episodeUrls.length === 0) {
            output.textContent = "è©±ç•ªå·ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“";
            return;
          }

          if (episodeUrls.length !== episodes.length) {
            output.textContent = `âŒ æŒ‡å®š ${episodes.length} è©±ã®ã†ã¡URLã‚’è§£æ±ºã§ããŸã®ã¯ ${episodeUrls.length} è©±ã§ã™ã€‚è©±ç•ªå·æŒ‡å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚`;
            return;
          }
          
          // è‘—è€…åã¨ã‚¿ã‚¤ãƒˆãƒ«ã‚’å–å¾—
          const author = epubAuthorInput.value.trim() || workData.data.author || "Unknown";
          const title = epubTitleInput.value.trim() || workData.data.title || "Untitled";
          
          output.textContent = `EPUBç”Ÿæˆãƒ»é€ä¿¡ã‚¸ãƒ§ãƒ–ã‚’é–‹å§‹ä¸­... (${episodeUrls.length}è©±äºˆå®š)`;
          
          // /api/generate-epub ã§ãƒ¡ãƒ¼ãƒ«é€ä¿¡ãƒ¢ãƒ¼ãƒ‰ã§å‘¼ã³å‡ºã—
          const mailRes = await postJson("/api/generate-epub", {
            workUrl: url,
            episodeUrls,
            author,
            title,
            sendEmail: true,
            smtp,
            recipient: mailRecipient
          });
          const mailData = await readResponseJson(mailRes);
          
          if (mailRes.status === 202 && mailData.jobId) {
            // ã‚¸ãƒ§ãƒ–ãŒé–‹å§‹ã•ã‚ŒãŸ - ãƒãƒ¼ãƒªãƒ³ã‚°ã§é€²æ—ã‚’ç¢ºèª
            const jobId = mailData.jobId;
            let completed = false;
            
            while (!completed) {
              await new Promise(resolve => setTimeout(resolve, 500)); // 0.5ç§’ã”ã¨ã«ãƒãƒ¼ãƒªãƒ³ã‚°
              
              const progressRes = await fetch(`${apiBase}/api/job-progress/${jobId}`, { cache: "no-store" });
              if (!progressRes.ok) {
                output.textContent = "é€²æ—ç¢ºèªã«å¤±æ•—ã—ã¾ã—ãŸ";
                break;
              }
              
              const progress = await progressRes.json();
              if (progress.status === "processing") {
                output.textContent = `${progress.message || "EPUBç”Ÿæˆãƒ»é€ä¿¡ä¸­..."} (${progress.progress}/${progress.total}è©±)`;
              } else {
                output.textContent = `${progress.message || `EPUBç”Ÿæˆãƒ»é€ä¿¡ä¸­... ${progress.progress}/${progress.total}è©±`}`;
              }
              
              if (progress.status === "completed") {
                output.textContent = `âœ… ${progress.message || `ãƒ¡ãƒ¼ãƒ«é€ä¿¡å®Œäº† (${progress.total}è©±)`}`;
                saveSettings();
                completed = true;
              } else if (progress.status === "error") {
                output.textContent = `âŒ ã‚¨ãƒ©ãƒ¼: ${progress.error || "ä¸æ˜ãªã‚¨ãƒ©ãƒ¼"}`;
                completed = true;
              }
            }
          } else {
            const errorMsg = mailData.error || "ä¸æ˜ãªã‚¨ãƒ©ãƒ¼";
            const detailMsg = mailData.message ? `\n\n${mailData.message}` : "";
            output.textContent = `é€ä¿¡ã‚¨ãƒ©ãƒ¼: ${errorMsg}${detailMsg}`;
          }
        } catch (err) {
          output.textContent = `ã‚¨ãƒ©ãƒ¼: ${err.message || err}`;
        }
      });
    </script>
  </body>
</html>
